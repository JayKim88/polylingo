import {
  initConnection,
  endConnection,
  purchaseUpdatedListener,
  purchaseErrorListener,
  Purchase,
  PurchaseError,
  requestPurchase,
  getSubscriptions,
  finishTransaction,
  getAvailablePurchases,
  acknowledgePurchaseAndroid,
  Subscription,
  ProductPurchase,
} from 'react-native-iap';
import { Platform, Alert } from 'react-native';
import i18n from '../i18n';

import { SubscriptionService } from './subscriptionService';
import { UserService } from './userService';
import { IAP_PRODUCT_IDS } from '../types/subscription';
import { useSubscriptionStore } from '../stores/subscriptionStore';
import { captureIAPError, addBreadcrumb, trackUserAction } from './sentryUtils';

type InitializationResult = {
  success: boolean;
  error?: string;
};

const CONSTANTS = {
  VALIDATION_TIMEOUT: 10000,
  RETRY_DELAY: 1000,
  YEAR_IN_MS: 365 * 24 * 60 * 60 * 1000,
  MONTH_IN_MS: 30 * 24 * 60 * 60 * 1000,
} as const;

const ERROR_CODES = {
  IAP_NOT_AVAILABLE: 'E_IAP_NOT_AVAILABLE',
  USER_CANCELLED: 'E_USER_CANCELLED',
} as const;

export class IAPService {
  private static purchaseUpdateSubscription: any;
  private static purchaseErrorSubscription: any;
  private static isInitialized = false;
  private static isAvailable = false;
  private static processedPurchases = new Set<string>(); // Ï≤òÎ¶¨Îêú Íµ¨Îß§ Ï∂îÏ†Å
  private static isProcessingRestore = false; // Î≥µÏõê Ï≤òÎ¶¨ Ï§ë ÌîåÎûòÍ∑∏
  private static initializationPromise: Promise<boolean> | null = null; // Ï¥àÍ∏∞Ìôî Ï§ëÎ≥µ Î∞©ÏßÄ
  // Apple auth state removed - using transaction-based identification
  private static lastSubscriptionCheck = 0; // ÎßàÏßÄÎßâ Íµ¨ÎèÖ Ï≤¥ÌÅ¨ ÏãúÍ∞Ñ
  private static SUBSCRIPTION_CHECK_INTERVAL = 2 * 60 * 1000; // 2Î∂Ñ

  static async initialize(): Promise<boolean> {
    if (this.initializationPromise) {
      return await this.initializationPromise;
    }

    if (this.isInitialized) {
      return true;
    }

    this.initializationPromise = this.performInitializationSequence();
    return await this.initializationPromise;
  }

  private static async performInitializationSequence(): Promise<boolean> {
    try {
      await this.performInitialization();
      // Skip Apple authentication - use transaction-based identification instead
      return true;
    } catch (error) {
      this.initializationPromise = null;
      throw error;
    } finally {
      this.initializationPromise = null;
    }
  }

  private static async performInitialization(): Promise<InitializationResult> {
    try {
      console.log('Initializing IAP service...');

      // Í∏∞Ï°¥ Ïó∞Í≤∞Ïù¥ ÏûàÏúºÎ©¥ Î®ºÏ†Ä Ï†ïÎ¶¨
      if (this.isInitialized) {
        await this.cleanup();
      }

      await initConnection();
      this.isInitialized = true;
      this.isAvailable = true;
      this.setupPurchaseListeners();
      return { success: true };
    } catch (error) {
      console.error('IAP initialization failed:', error);
      this.isInitialized = false;
      this.isAvailable = false;

      const errorMessage = this.getErrorMessage(error);
      if (errorMessage === ERROR_CODES.IAP_NOT_AVAILABLE) {
        console.log(
          'IAP not available - likely running in simulator or development build'
        );
        return { success: false, error: errorMessage };
      }

      return { success: false, error: errorMessage };
    }
  }

  private static getErrorMessage(error: unknown): string {
    return typeof error === 'object' && error !== null && 'message' in error
      ? (error as any).message
      : 'Unknown error';
  }

  static isIAPAvailable(): boolean {
    return this.isAvailable;
  }

  // Apple authentication methods removed - using transaction-based identification

  // Apple authentication methods removed - using transaction-based identification only

  // TestFlight/Sandbox ÌôòÍ≤Ω Í∞êÏßÄ
  private static determineTestEnvironment(): boolean {
    // 1. Í∞úÎ∞ú Î™®ÎìúÎäî Î¨¥Ï°∞Í±¥ Sandbox
    if (__DEV__) {
      return true;
    }

    // 2. ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Í∞ïÏ†ú ÏÑ§Ï†ï (TestFlight Î∞∞Ìè¨Ïö©)
    if (process.env.EXPO_PUBLIC_IAP_USE_SANDBOX === 'true') {
      console.log('Forced sandbox mode via environment variable');
      return true;
    }

    // 3. Expo ÌôòÍ≤Ω Ï≤¥ÌÅ¨
    if (process.env.NODE_ENV !== 'production') {
      console.log('Non-production environment - using Sandbox');
      return true;
    }

    // 4. Í∏∞Î≥∏Í∞í: Production (App Store)
    console.log('Production environment - using Production server');
    return false;
  }

  private static setupPurchaseListeners() {
    if (this.purchaseUpdateSubscription) {
      this.purchaseUpdateSubscription.remove();
      this.purchaseUpdateSubscription = null;
    }
    this.purchaseUpdateSubscription = purchaseUpdatedListener(
      async (purchase: Purchase) => {
        // Use transaction ID as primary identifier to prevent duplicate processing of same transaction
        const transactionId =
          purchase.originalTransactionIdentifierIOS || purchase.purchaseToken;
        const purchaseId = __DEV__
          ? purchase.productId
          : transactionId || purchase.productId;

        // Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú Íµ¨Îß§Ïù∏ÏßÄ ÌôïÏù∏ (Ï§ëÎ≥µ Ï≤òÎ¶¨ Î∞©ÏßÄ)
        if (this.processedPurchases.has(purchaseId)) {
          console.log(`Purchase already processed: ${purchaseId}`);
          return;
        }

        // Î≥µÏõê Ï≤òÎ¶¨ Ï§ëÏù¥Î©¥ Î¶¨Ïä§ÎÑà Î¨¥Ïãú (Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄ)
        if (this.isProcessingRestore) {
          console.log('Restore in progress - skipping purchase listener');
          return;
        }

        console.log(
          'üéâ New purchase detected:',
          purchase.productId,
          'ID:',
          purchaseId
        );

        // SentryÏóê Íµ¨Îß§ ÏãúÏûë Ï∂îÏ†Å
        trackUserAction('purchase_detected', {
          product_id: purchase.productId,
          purchase_id: purchaseId,
          platform: Platform.OS,
        });

        try {
          this.processedPurchases.add(purchaseId);

          const isValid = await this.validatePurchase(purchase);

          if (isValid) {
            // Check if this is a restored purchase (app restart) vs new purchase
            const existingTransactionId =
              await UserService.getCurrentTransactionId();
            const isRestoredPurchase =
              existingTransactionId ===
              purchase.originalTransactionIdentifierIOS;

            if (isRestoredPurchase) {
              // This is a restored purchase - preserve usage
              console.log('üîÑ Restored purchase detected, preserving usage');
              await this.handleSuccessfulPurchaseQuietly(purchase);
            } else {
              // This is a new purchase - reset usage
              console.log('üéâ New purchase detected, resetting usage');
              await this.handleSuccessfulPurchase(purchase);
            }

            await finishTransaction({
              purchase,
              isConsumable: false,
              developerPayloadAndroid: undefined,
            });
          } else {
            this.processedPurchases.delete(purchaseId);
          }
        } catch (error) {
          console.error('Purchase validation error:', error);

          // SentryÏóê IAP ÏóêÎü¨ Ï†ÑÏÜ°
          captureIAPError(error as Error, {
            productId: purchase.productId,
            transactionId:
              purchase.originalTransactionIdentifierIOS ||
              purchase.purchaseToken,
            step: 'purchase_validation',
          });

          Alert.alert('Íµ¨Îß§ Ïò§Î•ò', 'Íµ¨Îß§ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
          // ÏóêÎü¨ Î∞úÏÉù Ïãú Ï≤òÎ¶¨Îê® ÌëúÏãú Ï†úÍ±∞ (Ïû¨ÏãúÎèÑ Í∞ÄÎä•ÌïòÍ≤å)
          this.processedPurchases.delete(purchaseId);
        }
      }
    );

    // Íµ¨Îß§ Ïã§Ìå® Î¶¨Ïä§ÎÑà
    this.purchaseErrorSubscription = purchaseErrorListener(
      (error: PurchaseError) => {
        console.error('Purchase error in listener:', error);

        if (error.code !== 'E_USER_CANCELLED') {
          Alert.alert(
            'Íµ¨Îß§ Ïã§Ìå®',
            error.message || 'Íµ¨Îß§ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
          );
        }
      }
    );
  }

  // Íµ¨ÎèÖ ÏÉÅÌíà Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
  static async getSubscriptionProducts(): Promise<Subscription[]> {
    try {
      // Check if IAP is available
      if (!this.isAvailable) {
        console.log(
          'IAP not available - returning simulation products for development'
        );
        return this.getSimulationProducts();
      }

      // Ensure IAP is initialized before getting products
      if (!this.isInitialized) {
        const initialized = await this.initialize();
        if (!initialized) {
          console.error(
            'Failed to initialize IAP service - returning simulation products'
          );
          return this.getSimulationProducts();
        }
      }

      const productIds = Object.values(IAP_PRODUCT_IDS);
      const products = await getSubscriptions({ skus: productIds });

      if (products.length === 0 && __DEV__) {
        console.log(
          'No products found in App Store Connect - returning simulation products for development'
        );
        return this.getSimulationProducts();
      }

      return products;
    } catch (error) {
      console.error('Failed to get subscription products:', error);

      if (__DEV__) {
        console.log('Returning simulation products for development testing');
        return this.getSimulationProducts();
      }

      return [];
    }
  }

  // Í∞úÎ∞úÏö© ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏÉÅÌíà Î™©Î°ù (App Store Connect ÎØ∏Îì±Î°ù Ïãú ÏÇ¨Ïö©)
  private static getSimulationProducts(): Subscription[] {
    if (!__DEV__) return [];

    const simulationProducts = [
      {
        productId: IAP_PRODUCT_IDS.PRO_MONTHLY,
        title: 'Pro Monthly Subscription',
        price: '2.99',
      },
      {
        productId: IAP_PRODUCT_IDS.PRO_MAX_MONTHLY,
        title: 'Pro Max Monthly Subscription',
        price: '4.99',
      },
      {
        productId: IAP_PRODUCT_IDS.PREMIUM_YEARLY,
        title: 'Premium Yearly Subscription',
        price: '29.99',
      },
    ];

    return simulationProducts.map((product) => ({
      ...product,
      description: `${product.title.split(' ')[0]} features with ${
        product.title.includes('Yearly') ? 'yearly' : 'monthly'
      } billing`,
      currency: 'USD',
      localizedPrice: `$${product.price}`,
      countryCode: 'US',
    })) as Subscription[];
  }

  // Íµ¨ÎèÖ Íµ¨Îß§ Ïã§Ìñâ
  static async purchaseSubscription(
    productId: string
  ): Promise<ProductPurchase | null> {
    if (!this.ensureIAPAvailability()) {
      return null;
    }

    if (!this.isInitialized) {
      await this.ensureInitialized();
    }

    addBreadcrumb(`Starting purchase for ${productId}`, 'iap');

    try {
      const result = await requestPurchase({ sku: productId });
      return result ? (result as ProductPurchase) : null;
    } catch (error: any) {
      console.error('Purchase failed:', error);

      // SentryÏóê Íµ¨Îß§ Ïã§Ìå® ÏóêÎü¨ Ï†ÑÏÜ°
      captureIAPError(error, {
        productId,
        step: 'purchase_request',
      });

      // ÏÇ¨Ïö©ÏûêÍ∞Ä Ï∑®ÏÜåÌïú Í≤ΩÏö∞ ÏóêÎü¨Î•º Îã§Ïãú throwÌïòÏó¨ ÏÉÅÏúÑÏóêÏÑú Ï≤òÎ¶¨Ìï† Ïàò ÏûàÎèÑÎ°ù Ìï®
      if (
        error?.code === 'E_USER_CANCELLED' ||
        error?.message?.includes('cancel') ||
        error?.message?.includes('Cancel') ||
        error?.userCancelled === true
      ) {
        throw error; // Ï∑®ÏÜå ÏóêÎü¨Î•º ÏÉÅÏúÑÎ°ú Ï†ÑÎã¨
      }

      return null;
    }
  }

  private static ensureIAPAvailability(): boolean {
    if (!this.isAvailable) {
      Alert.alert(
        'IAP Unavailable',
        'In-app purchases are not available in this environment'
      );
      return false;
    }
    return true;
  }

  private static async ensureInitialized(): Promise<boolean> {
    if (this.isInitialized) {
      return true;
    }

    const initialized = await this.initialize();
    if (!initialized) {
      throw new Error('IAP service not initialized');
    }
    return true;
  }

  // Íµ¨Îß§ Î≥µÏõê
  static async restorePurchases(): Promise<boolean> {
    console.log('Starting restore purchases...');

    if (__DEV__ && !this.isAvailable) {
      return this.simulateRestoreInDevelopment();
    }

    if (!this.ensureIAPAvailability()) {
      return false;
    }

    try {
      console.log('‚è≥ Fetching available purchases from Apple...');

      // getAvailablePurchasesÏóê ÌÉÄÏûÑÏïÑÏõÉ Ï†ÅÏö© (30Ï¥à)
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(
          () =>
            reject(new Error('Restore timeout - Apple server took too long')),
          30000
        );
      });

      const restorePromise = getAvailablePurchases({
        onlyIncludeActiveItems: true,
      });
      const restored = await Promise.race([restorePromise, timeoutPromise]);

      if (restored.length === 0) {
        Alert.alert(
          i18n.t('subscription.restoreComplete'),
          i18n.t('subscription.noItemsToRestore')
        );
        return false;
      }

      return this.processRestoredPurchases(restored);
    } catch (error) {
      console.error('Restore failed:', error);

      if (error instanceof Error && error.message?.includes('timeout')) {
        Alert.alert(
          i18n.t('subscription.restoreTimeout'),
          i18n.t('subscription.restoreTimeoutMessage')
        );
      } else {
        this.handleRestoreError();
      }
      return false;
    }
  }

  private static simulateRestoreInDevelopment(): boolean {
    console.log('Simulating restore in development mode');
    Alert.alert(
      'Í∞úÎ∞ú Î™®Îìú Î≥µÏõê ÏãúÎÆ¨Î†àÏù¥ÏÖò',
      'Íµ¨Îß§ Î≥µÏõêÏùÑ ÏãúÎÆ¨Î†àÏù¥ÏÖòÌï©ÎãàÎã§.\n\nÌòÑÏû¨ Íµ¨ÎèÖ ÏÉÅÌÉúÎ•º ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî.',
      [{ text: 'ÌôïÏù∏', onPress: () => {} }]
    );
    return true;
  }

  private static async processRestoredPurchases(
    restored: Purchase[]
  ): Promise<boolean> {
    this.isProcessingRestore = true;

    try {
      // Í∞ÄÏû• ÏµúÏã† Íµ¨Îß§Îßå Ï≤òÎ¶¨ (Ïò§ÎûòÎêú Íµ¨Îß§Îì§ÏùÄ Î¨¥Ïãú)
      const latestPurchase = restored.sort(
        (a: Purchase, b: Purchase) =>
          (b.transactionDate || 0) - (a.transactionDate || 0)
      )[0];

      if (latestPurchase) {
        const isValid = await this.validatePurchase(latestPurchase);

        if (isValid) {
          await this.handleSuccessfulPurchaseQuietly(latestPurchase);
          return true;
        } else {
          Alert.alert(
            i18n.t('subscription.subscriptionStatus'),
            i18n.t('subscription.noActiveSubscription'),
            [{ text: i18n.t('alert.confirm') }]
          );
          console.log('Latest purchase validation failed');
          return false;
        }
      }

      // Î™®Îì† Î≥µÏõêÎêú Íµ¨Îß§Î•º Ï≤òÎ¶¨Îê®ÏúºÎ°ú ÌëúÏãú (Î¶¨Ïä§ÎÑà Ïû¨Ìä∏Î¶¨Í±∞ Î∞©ÏßÄ)
      for (const purchase of restored) {
        const purchaseId = __DEV__
          ? purchase.productId
          : `${purchase.productId}_${
              purchase.originalTransactionIdentifierIOS ||
              purchase.purchaseToken
            }`;
        this.processedPurchases.add(purchaseId);
        console.log(`Marked as processed: ${purchaseId} (DEV: ${__DEV__})`);
      }
      return false;
    } catch {
      Alert.alert(
        i18n.t('subscription.restoreError'),
        i18n.t('subscription.restoreErrorMessage')
      );
      return false;
    } finally {
      this.isProcessingRestore = false;
    }
  }

  private static handleRestoreError(): void {
    const message = __DEV__
      ? 'Ïã§Ï†ú Î≥µÏõêÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.\n\nÍ∞úÎ∞ú Î™®ÎìúÏóêÏÑúÎäî ÏÑ§Ï†ïÏóêÏÑú Íµ¨ÎèÖÏùÑ ÏßÅÏ†ë Í¥ÄÎ¶¨Ìï† Ïàò ÏûàÏäµÎãàÎã§.'
      : 'Íµ¨Îß§ Î≥µÏõê Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';

    Alert.alert('Î≥µÏõê Ïã§Ìå®', message, [{ text: 'ÌôïÏù∏' }]);
  }

  private static async validatePurchase(purchase: Purchase): Promise<boolean> {
    try {
      const timeoutPromise = this.createTimeoutPromise();
      const validationPromise = this.performPlatformValidation(purchase);

      return await Promise.race([validationPromise, timeoutPromise]);
    } catch (error) {
      return this.handleValidationError(error, purchase);
    }
  }

  private static createTimeoutPromise(): Promise<boolean> {
    return new Promise<boolean>((_, reject) => {
      setTimeout(
        () => reject(new Error('Validation timeout')),
        CONSTANTS.VALIDATION_TIMEOUT
      );
    });
  }

  private static async performPlatformValidation(
    purchase: Purchase
  ): Promise<boolean> {
    if (Platform.OS === 'ios') {
      return await this.validateIOSPurchase(purchase);
    } else {
      return this.validateAndroidPurchase(purchase);
    }
  }

  private static async validateIOSPurchase(
    purchase: Purchase
  ): Promise<boolean> {
    try {
      // Use server-side validation API
      const baseUrl = process.env.EXPO_PUBLIC_API_BASE_URL;
      const apiUrl = baseUrl ? `${baseUrl}/api/iap/verify` : '/api/iap/verify';

      const isTestEnvironment = this.determineTestEnvironment();

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': process.env.EXPO_PUBLIC_IAP_API_KEY || '',
        },
        body: JSON.stringify({
          receiptData: purchase.transactionReceipt,
          isTest: isTestEnvironment,
          platform: 'ios',
        }),
      });

      if (!response.ok) {
        throw new Error(`Server responded with ${response.status}`);
      }

      const result = await response.json();

      if (!result.isValid) {
        console.log('‚ùå Apple validation failed on server');
        return false;
      }

      // expiresDateÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ ÌòÑÏû¨ ÏãúÍ∞ÑÍ≥º ÎπÑÍµêÌïòÏó¨ ÎßåÎ£å Ïó¨Î∂Ä ÌôïÏù∏
      if (result.expiresDate) {
        const expiresTime = new Date(result.expiresDate).getTime();
        const now = Date.now();
        const isActive = now < expiresTime;

        return isActive;
      }

      return result.isValid;
    } catch (error) {
      console.error('Server validation failed:', error);
      if (__DEV__) {
        return !!(purchase.productId && purchase.transactionReceipt);
      }
      return false;
    }
  }

  private static validateAndroidPurchase(purchase: Purchase): boolean {
    console.log(
      'Android validation not fully implemented - accepting purchase'
    );
    return !!(purchase.productId && purchase.purchaseToken);
  }

  private static handleValidationError(
    error: unknown,
    purchase: Purchase
  ): boolean {
    console.error('Purchase validation error:', error);

    const errorMessage = error instanceof Error ? error.message : String(error);
    if (__DEV__ || errorMessage.includes('timeout')) {
      console.log('Validation failed but accepting purchase in development');
      return !!(purchase.productId && purchase.purchaseToken);
    }

    return false;
  }

  // ÏÑ±Í≥µÏ†ÅÏù∏ Íµ¨Îß§ Ï≤òÎ¶¨ - Ìä∏ÎûúÏû≠ÏÖò IDÎ•º ÏÇ¨Ïö©Ïûê ÏãùÎ≥ÑÏûêÎ°ú ÏÇ¨Ïö©
  private static async handleSuccessfulPurchase(purchase: Purchase) {
    try {
      const productId = purchase.productId;
      const transactionId = purchase.originalTransactionIdentifierIOS;

      if (!transactionId) {
        throw new Error('Missing transaction identifier for purchase');
      }

      // Íµ¨ÎèÖ ÌîåÎûú ID Îß§Ìïë
      let planId: string;
      switch (productId) {
        case IAP_PRODUCT_IDS.PRO_MONTHLY:
          planId = 'pro_monthly';
          break;
        case IAP_PRODUCT_IDS.PRO_MAX_MONTHLY:
          planId = 'pro_max_monthly';
          break;
        case IAP_PRODUCT_IDS.PREMIUM_YEARLY:
          planId = 'premium_yearly';
          break;
        default:
          throw new Error(`Unknown product ID: ${productId}`);
      }

      // Transaction ID Ï†ÄÏû•
      await UserService.saveTransactionId(transactionId);

      // ÏÉà Íµ¨Îß§ Ïãú ÏÇ¨Ïö©Îüâ Ï¥àÍ∏∞ÌôîÌïòÏó¨ Íµ¨ÎèÖ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Ìä∏ÎûúÏû≠ÏÖò ID Í∏∞Î∞ò)
      console.log(
        `üîÑ Activating subscription for transaction: ${transactionId}`
      );
      try {
        await SubscriptionService.setSubscription(
          planId,
          {
            isActive: true,
            preserveUsage: false,
          },
          transactionId
        );
      } catch (syncError) {
        console.error(
          'Failed to sync subscription to server - setting to free:',
          syncError
        );
        // ÏÑúÎ≤Ñ ÎèôÍ∏∞Ìôî Ïã§Ìå® Ïãú freeÎ°ú ÏÑ§Ï†ï (Ïù¥ÎØ∏ syncToServerÏóêÏÑú Ï≤òÎ¶¨Îê®)
        Alert.alert(
          i18n.t('alert.error'),
          'Server synchronization failed. Your subscription has been reset to free plan.',
          [{ text: i18n.t('alert.confirm') }]
        );
        return; // ÏóêÎü¨ Ïãú Îçî Ïù¥ÏÉÅ ÏßÑÌñâÌïòÏßÄ ÏïäÏùå
      }

      // AndroidÏóêÏÑú Íµ¨Îß§ ÏäπÏù∏
      if (Platform.OS === 'android' && purchase.purchaseToken) {
        await acknowledgePurchaseAndroid({
          token: purchase.purchaseToken,
          developerPayload: undefined,
        });
      }

      console.log(
        `Subscription activated: ${planId} for transaction: ${transactionId}`
      );
    } catch (error) {
      console.error('Failed to handle successful purchase:', error);
      throw error;
    }
  }

  // Î≥µÏõê Ïãú Ï°∞Ïö©Ìûà Ï≤òÎ¶¨ (Î¶¨Ïä§ÎÑà Ìä∏Î¶¨Í±∞ Î∞©ÏßÄ) - Ìä∏ÎûúÏû≠ÏÖò IDÎ•º ÏÇ¨Ïö©Ïûê ÏãùÎ≥ÑÏûêÎ°ú ÏÇ¨Ïö©
  private static async handleSuccessfulPurchaseQuietly(purchase: Purchase) {
    try {
      const productId = purchase.productId;
      const transactionId = purchase.originalTransactionIdentifierIOS;

      if (!transactionId) {
        throw new Error('Missing transaction identifier for restore');
      }

      // Íµ¨ÎèÖ ÌîåÎûú ID Îß§Ìïë
      let planId: string;
      switch (productId) {
        case IAP_PRODUCT_IDS.PRO_MONTHLY:
          planId = 'pro_monthly';
          break;
        case IAP_PRODUCT_IDS.PRO_MAX_MONTHLY:
          planId = 'pro_max_monthly';
          break;
        case IAP_PRODUCT_IDS.PREMIUM_YEARLY:
          planId = 'premium_yearly';
          break;
        default:
          throw new Error(`Unknown product ID: ${productId}`);
      }

      // Transaction ID Ï†ÄÏû•
      await UserService.saveTransactionId(transactionId);

      // Íµ¨ÎèÖ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Ï°∞Ïö©Ìûà) - Ìä∏ÎûúÏû≠ÏÖò ID Í∏∞Î∞ò
      try {
        await SubscriptionService.setSubscription(
          planId,
          {
            isActive: true,
            preserveUsage: true,
          },
          transactionId
        );
      } catch (syncError) {
        console.error(
          'Failed to sync subscription to server during restore - setting to free:',
          syncError
        );
        // ÏÑúÎ≤Ñ ÎèôÍ∏∞Ìôî Ïã§Ìå® Ïãú ÏóêÎü¨Î•º throwÌïòÏó¨ ÏÉÅÏúÑÏóêÏÑú Ï≤òÎ¶¨
        throw syncError;
      }

      console.log(
        `Subscription restored quietly: ${planId} for transaction: ${transactionId}`
      );
    } catch (error) {
      console.error('Failed to handle successful purchase quietly:', error);
      throw error;
    }
  }

  static async setSubscriptionFreeWithPreserve() {
    await SubscriptionService.setSubscription('free', {
      isActive: true,
      preserveUsage: true,
    });
  }

  /**
   * @description ÌòÑÏû¨ Íµ¨ÎèÖ ÏÉÅÌÉú ÌôïÏù∏ (Íµ¨ÎèÖ Î™®Îã¨ÏóêÏÑúÎßå Ìò∏Ï∂ú) ÌõÑ,
   * Íµ¨ÎèÖ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Supabase ÎèôÍ∏∞Ìôî Ìè¨Ìï®)
   */
  static async checkSubscriptionStatusAndUpdate(
    checkFromActive?: boolean
  ): Promise<void> {
    if (checkFromActive) {
      const now = Date.now();
      const isRecentlyChecked =
        now - this.lastSubscriptionCheck < this.SUBSCRIPTION_CHECK_INTERVAL;

      if (isRecentlyChecked) return;

      this.lastSubscriptionCheck = now;
    }

    // Ïù¥ÎØ∏ Ï≤¥ÌÅ¨ Ï§ëÏù¥Î©¥ Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ
    const store = useSubscriptionStore.getState();
    if (store.isCheckingSubscription) {
      console.log('Subscription check already in progress - skipping');
      return;
    }
    store.setIsCheckingSubscription(true);

    try {
      // If IAP is not available, set to free plan
      if (!this.isAvailable) {
        console.log('IAP not available - setting to free plan');
        await this.setSubscriptionFreeWithPreserve();
        return;
      }

      // Ensure IAP is initialized before checking purchases
      if (!this.isInitialized) {
        console.log('IAP not initialized - initializing now...');
        const initialized = await this.initialize();
        if (!initialized) {
          await this.setSubscriptionFreeWithPreserve();
          return;
        }
      }

      console.log('Checking subscription status...');

      let restored: Purchase[] = [];
      let detectedSubscriptionPlan = 'free';
      let originalTransactionId: string | undefined;

      try {
        // Íµ¨Îß§ Î≥µÏõê (Apple ID Ïù∏Ï¶ù ÏóÜÏù¥)
        restored = await getAvailablePurchases({
          onlyIncludeActiveItems: true,
        });

        console.log(`Found ${restored.length} total purchases from Apple`);
      } catch (purchaseError) {
        console.warn('Failed to get available purchases:', purchaseError);
        // Failed to access purchases - set to free plan
        await this.setSubscriptionFreeWithPreserve();
        return;
      }

      if (restored.length === 0) {
        console.log(
          'No purchases found - user may have cancelled subscription'
        );
        detectedSubscriptionPlan = 'free';
      } else {
        // transactionDateÎßåÏúºÎ°ú Ï†ïÎ†¨ (Í∞ÄÏû• Ïã†Î¢∞Ìï† Ïàò ÏûàÎäî Í∏∞Ï§Ä) - Í∞ÄÏû• ÏµúÏã† Í≤∞Ï†ú ÏÉÅÌíà
        const sortedPurchases = restored.sort((a: Purchase, b: Purchase) => {
          const dateA = a.transactionDate || 0;
          const dateB = b.transactionDate || 0;
          return dateB - dateA;
        });

        const latestPurchase = sortedPurchases[0];

        originalTransactionId = latestPurchase.originalTransactionIdentifierIOS;

        // ÏÑúÎ≤ÑÎ•º ÌÜµÌï¥ Ïã§Ï†ú Íµ¨ÎèÖ ÏÉÅÌÉú Í≤ÄÏ¶ù (ÎßåÎ£å/Ï∑®ÏÜå Ïó¨Î∂Ä ÌôïÏù∏)
        try {
          const isValid = await this.validatePurchase(latestPurchase);

          if (isValid) {
            await this.handleSuccessfulPurchaseQuietly(latestPurchase);

            /**
             * @description cannot return free
             */
            switch (latestPurchase.productId) {
              case IAP_PRODUCT_IDS.PRO_MONTHLY:
                detectedSubscriptionPlan = 'pro_monthly';
                break;
              case IAP_PRODUCT_IDS.PRO_MAX_MONTHLY:
                detectedSubscriptionPlan = 'pro_max_monthly';
                break;
              case IAP_PRODUCT_IDS.PREMIUM_YEARLY:
                detectedSubscriptionPlan = 'premium_yearly';
                break;
              default:
                detectedSubscriptionPlan = 'free';
            }
            console.log(
              `‚úÖ Setting active subscription to: ${detectedSubscriptionPlan}`
            );
          } else {
            console.log(
              `‚ùå Server validation failed for ${latestPurchase.productId} - subscription is expired or cancelled`
            );
            detectedSubscriptionPlan = 'free';
          }
        } catch (validationError) {
          console.warn(
            `‚ùå Server validation error for ${latestPurchase.productId}:`,
            validationError
          );
          console.log('Defaulting to free plan due to validation error');
          detectedSubscriptionPlan = 'free';
        }
      }

      // ÏÑúÎ≤ÑÏùò Í∏∞Ï°¥ Íµ¨ÎèÖÍ≥º Í∞êÏßÄÎêú ÏÉÅÌÉú ÎπÑÍµê (Ïï± Ïû¨ÏÑ§Ïπò Ïãú Î°úÏª¨ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùÑ Ïàò ÏûàÏùå)
      const serverSub = await UserService.getLatestSubscriptionFromServer(
        originalTransactionId
      );
      const isNewSubscription = serverSub?.plan_id !== detectedSubscriptionPlan;

      const isPaidNewPlan =
        detectedSubscriptionPlan !== 'free' && isNewSubscription;

      if (isPaidNewPlan) {
        console.log(
          `üìà Subscription change detected: ${serverSub?.plan_id} ‚Üí ${detectedSubscriptionPlan}`
        );

        // ÏÉàÎ°úÏö¥ Íµ¨ÎèÖÏù¥ÎÇò ÌîåÎûú Î≥ÄÍ≤Ω Ïãú ÏÇ¨Ïö©Îüâ Ï¥àÍ∏∞Ìôî
        try {
          await SubscriptionService.setSubscription(
            detectedSubscriptionPlan,
            {
              isActive: true,
              preserveUsage: false, // ÏÇ¨Ïö©Îüâ Ï¥àÍ∏∞Ìôî
            },
            originalTransactionId
          );
        } catch (syncError) {
          console.error(
            'Failed to sync new subscription to server - setting to free:',
            syncError
          );
          detectedSubscriptionPlan = 'free';
          await this.setSubscriptionFreeWithPreserve();
        }
      } else {
        console.log(`‚úÖ Same subscription plan: ${detectedSubscriptionPlan}`);
        // ÎèôÏùºÌïú ÌîåÎûúÏù¥Î©¥ ÏÇ¨Ïö©Îüâ Î≥¥Ï°¥
        try {
          await SubscriptionService.setSubscription(
            detectedSubscriptionPlan,
            {
              isActive: true,
              preserveUsage: true,
            },
            originalTransactionId
          );
        } catch (syncError) {
          console.error(
            'Failed to sync existing subscription to server - setting to free:',
            syncError
          );
          await this.setSubscriptionFreeWithPreserve();
        }
      }
    } catch (error) {
      console.error('Failed to check subscription status:', error);
      await this.setSubscriptionFreeWithPreserve();
    } finally {
      useSubscriptionStore.getState().setIsCheckingSubscription(false);
    }
  }

  // IAP ÏÑúÎπÑÏä§ Ï¢ÖÎ£å
  static async cleanup(): Promise<void> {
    try {
      if (this.purchaseUpdateSubscription) {
        this.purchaseUpdateSubscription.remove();
        this.purchaseUpdateSubscription = null;
      }

      if (this.purchaseErrorSubscription) {
        this.purchaseErrorSubscription.remove();
        this.purchaseErrorSubscription = null;
      }

      await endConnection();
      this.isInitialized = false;
    } catch (error) {
      console.error('IAP cleanup failed:', error);
    }
  }
}
